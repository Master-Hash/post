---
title: 打乱列表算法
description: 打乱列表可以用抓阄和洗牌算法实现；随机排序可以打乱，但不均匀，本文探讨了此现象的成因。
---

# 打乱列表算法

打乱列表可以用抓阄和洗牌算法实现；随机排序可以打乱，但不均匀，本文探讨了此现象的成因。

## 分析

乱序列表有以下两个特征：

- 原列表每种全排列等可能出现
- 新列表每一项等可能出现原列表任一项

后者可以方便地实现。

## 抓阄算法

名字是我自己起的，因为保证“新列表每一项等可能出现原列表任一项”的原理和抓阄公平的原理完全相同。

即：随机取走原列表一项，放入新列表末端，直到原列表为空。

## 优化：洗牌算法（Fisher-Yates shuffle）

逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置。这样每次循环，末尾就会固定下来一个随机数。

lodash 和 Python 的 `random.shuffle()` 均采用此算法。

可以从“参见”中找到 JavaScript 示例代码。

## 错误算法：`array.sort(() => Math.random() - 0.5)`

`Math.random() - 0.5` 正负随机，因此排序函数会随机地对数组中的元素进行重新排序。

我从信息组得知，C++ 这么写，会 Runtime Error，因为随机数很可能不满足传递性。

JavaScript 里，这样能跑起来，但并非所有的排列都具有相同的概率。这是为什么？

我的观点如下：每次比较回调时，结果都会二分，因此无论是什么排序算法，共比较多少次，结果情况总数一定是 2
的整数次幂；但相同情况数为全排列数，等于列表长度阶乘，长度 ≥3 时，不可能整除情况总数，因此不可能平分。

**正确算法和错误算法的差异在于，前者关注“和谁交换”，后者关注“是否交换”。**

## 驳论：两两比较即可纯乱序？

观点来自
[javascript随机打乱数组shuffle_黑夜人的博客-CSDN博客_javascript shuffle](https://blog.csdn.net/wulove52/article/details/85804728)

> 其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50%
> 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。\
> ————————————————\
> 版权声明：本文为CSDN博主「wulove52」的原创文章，遵循CC 4.0 BY-SA版权协议。

根据上文，两两比较依然不是乱序。

## 参见

- [JAVASCRIPT.INFO](https://zh.javascript.info/array-methods#sui-ji-pai-lie-shu-zu)

## 花絮

有一则古老的故事，讲两个演员互不相让，都想排在名单的第一位。老板把两人的名字贴在走马灯上，名字随走马灯转动，轮流出现在大厅的正面，这样两人都服气了。

这也是我坚持“友链顺序随机”的原因。

但在 JavaScript 中实现时，我发现 JavaScript 竟然没有自带乱序函数。

JAVASCRIPT.INFO 提供了两种算法。因为第一种代码量较少，并且可以写成伪纯函数（JavaScript
并没有封装随机副作用），我先采用了第一种错误算法。

后来在三月 7、8 号二诊模拟期间，我（摸鱼）研究了这两种算法，也就有了本文。

我还具体研究了很多排序算法的效果，手画了很多树状图来定量计算小列表的概率，不过我觉得没必要，就没写出来。
